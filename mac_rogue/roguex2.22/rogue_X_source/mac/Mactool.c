#include "macHeaders.h"//#include <Devices.h>//#include <Scrap.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include "curses.h"#include "rogue.h"WINDOW* curscr;extern WindowRef the_windo, itemWin;char optEnv[512];char fntName[256];char fntSize[256];enum {	dumpItem = 1,	dumpPictItem = 2,	saveItem =4,	optionItem = 5,	quitItem = 7};	// File Menuenum {	undoItem = 1,	cutItem = 3,	copyItem = 4,	pasteItem = 5,	clearItem = 6};	// Edit Menushort mCmd=0;char svFname[BUFSIZ];Boolean ok_go_on;Boolean gUseNavigation;Boolean gIsAqua;Boolean gMonoFontMenu = false;FSSpec msgSpec;AliasHandle tmpAlias=NULL;char msgPath[BUFSIZ];long gOSversion;MenuHandle appleMenu,fileMenu, editMenu,fontMenu,sizeMenu;extern	int read_mesg(int ac, char** av);extern print_stats(int stat_mask);extern	void reInit_window(void);extern	void maccur_cpu_share(void);extern	char *_maccur_font_name;extern	int	_maccur_font_size;extern	char *_maccur_pgm_name;extern	char *font_name;extern	char *font_size;//---local funcstatic void monoMenu(void);void macResetMessage(void);void makePath(FSSpecPtr myFSS);static void	SaveAsPict(void);void useItem(void);extern PicHandle GetWindowPict(void);long mySignature='jRge';#define prfID 200enum {	kOKButton = 1,	kCancelButton = 2,	kColorCheck = 3,	kshowMoveCheck = 4,	kPassGoCheck = 5,	kTombCheck = 6,	kFruite = 9,	kName = 10,	kMsg = 13,	kChooseMsg = 14,	kResetMsg = 15,	kFontMenuCheck = 16};#ifdef JAPAN#define prefsName "\pjrogue.prefs"#define PREF_ITEM "\p設定..."#define QUIT_ITEM "\p終了/Q"#define msg_file_msg "\pメッセージファイルを選んで下さい"#else#define prefsName "\progue.prefs"#define PREF_ITEM "\pPreferences..."#define QUIT_ITEM "\pQuit/Q"#define msg_file_msg "\pChoose message file."#endif#define msgResName "\pMessage File"#define msgName "default"short prefsRefNum;char *buildDefaultOpts(void){	static char opts[BUFSIZ];	Str255 fname;#ifdef JAPAN	char *defaultFont[]={		"Osaka−等幅",		"等幅ゴシック",		"等幅明朝",		"中ゴシックＢＢＢ−等幅",		"リュウミンライト−ＫＬ−等幅",		"ASLFont+",		NULL,	};#else	char *defaultFont[]={		"Monaco",		"Courier",		"Courier New",		NULL,	};#endif	int i;	short fnum=0;	opts[0] = 0;	strcat(opts,"jump,passgo,color,");	strcat(opts,"font:");	for (i = 0;defaultFont[i];i++){		int l = strlen(defaultFont[i]);		BlockMoveData(defaultFont[i],fname+1,l);		fname[0] = l;		GetFNum(fname,&fnum);		if (fnum >0 )			break;	}	if (fnum >0){		strcat(opts,defaultFont[i]);			} else {		strcat(opts,"Monaco");	}	strcat(opts,",size:12");		return opts;}void saveWindowPosition(void){	Rect r;	CFNumberRef left,top;	GetWindowBounds(the_windo, kWindowStructureRgn, &r);	left = CFNumberCreate(NULL,kCFNumberShortType, &r.left);	top = CFNumberCreate(NULL,kCFNumberShortType, &r.top);	CFPreferencesSetAppValue(CFSTR("WindowLeft"), left, kCFPreferencesCurrentApplication);	CFPreferencesSetAppValue(CFSTR("WindowTop"), top, kCFPreferencesCurrentApplication);	CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);	CFRelease(left);	CFRelease(top);}void loadWindowPosition(void){	short l, t;	CFNumberRef left,top;	Rect r;	RgnHandle rgn,wr,dr;	left = CFPreferencesCopyAppValue(CFSTR("WindowLeft"), kCFPreferencesCurrentApplication);	top = CFPreferencesCopyAppValue(CFSTR("WindowTop"), kCFPreferencesCurrentApplication);	if (left){		CFNumberGetValue( left, kCFNumberShortType, &l);		CFNumberGetValue( top, kCFNumberShortType, &t);		MoveWindowStructure(the_windo, l,t);		/*		dr = NewRgn();				GetWindowRegion(the_windo, kWindowStructureRgn, &wr);		rgn = DMGetDeskRegion(&rgn);		SectRgn(rgn,wr,dr);		if (EmptyRgn(dr)){			MoveWindowStructure(the_windo, 10,20);		}		*/		CFRelease(left);		CFRelease(top);	}	}void saveFontSetting(char* savefont, int savesize){	CFStringRef fontKey = CFSTR("Font");	CFStringRef sizeKey = CFSTR("Size");#ifdef JAPAN	UInt32 encoding = kCFStringEncodingMacJapanese;#else	UInt32 encoding = kCFStringEncodingMacRoman;#endif	CFStringRef fontRef = CFStringCreateWithCString(NULL, savefont, encoding);	CFNumberRef sizeRef = CFNumberCreate(NULL, kCFNumberIntType, &savesize);	if (fontRef){		CFPreferencesSetAppValue(fontKey, fontRef, kCFPreferencesCurrentApplication);		CFPreferencesSetAppValue(sizeKey, sizeRef, kCFPreferencesCurrentApplication);		CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);	}	CFRelease(fontRef);	CFRelease(sizeRef);	}char *buildCurrentOptStr(void){	extern opt envopt[];	static char optbuf[BUFSIZ];	int i;	optbuf[0] = 0;	for (i = 0; envopt[i].name !=NULL; i++) {		strcat(optbuf, ",");		if (envopt[i].bp) {			if (!(*(envopt[i].bp)))				strcat(optbuf, "no");			strcat(optbuf, envopt[i].name);		} else {			strcat(optbuf, envopt[i].name);			strcat(optbuf, ":");			strcat(optbuf, *(envopt[i].cp));		}	}	//printf( optbuf);	return optbuf;}//UInt8 gdir[BUFSIZ];char* getPrefsOpts(void){	char* defOpts;	static char outOpts[BUFSIZ];#ifdef JAPAN	UInt32 encoding = kCFStringEncodingMacJapanese;	char* defFont = "Osaka−等幅";#else	UInt32 encoding = kCFStringEncodingMacRoman;	char* defFont = "Monaco";#endif	SInt32 size = 12;	CFStringRef optKey = CFSTR("ROGUEOPTS");	CFStringRef optRef = CFPreferencesCopyAppValue(optKey,						kCFPreferencesCurrentApplication);	if (optRef == NULL){		defOpts = buildDefaultOpts();		optRef = CFStringCreateWithCString(NULL, defOpts, encoding);		CFPreferencesSetAppValue(optKey, optRef, kCFPreferencesCurrentApplication);		CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);		saveFontSetting(defFont,size);	}	if (CFStringGetCString(optRef,outOpts, BUFSIZ,encoding)){		return outOpts;	}	CFRelease(optRef);	return NULL;}static pascal void myNavEventProc( NavEventCallbackMessage callBackSelector, NavCBRecPtr callBackParms,			NavCallBackUserData callBackUD ){	#pragma unused(callBackUD)	extern int maccur_process1Event(int until_flags,EventRecord * event);	EventRecord* theEvent;	switch( callBackSelector){		case kNavCBEvent:			theEvent = callBackParms->eventData.eventDataParms.event;			switch (theEvent->what){				case updateEvt:					//maccur_process1Event(0,theEvent);					break;			}			break;	}}Boolean getNavFile(StringPtr message, FSSpecPtr resultSpec){	OSErr theErr = noErr;	NavReplyRecord theReply;	NavDialogOptions dialogOptions;	NavTypeListHandle openTypeList = NULL;	char *typ;	Boolean  result = false;	AEKeyword aKeyWord;	static FSSpec systemFile;#if TARGET_API_MAC_CARBON	NavEventUPP eventProc = NewNavEventUPP(myNavEventProc );#else	NavEventUPP eventProc = NewNavEventProc(myNavEventProc );#endif	//NavObjectFilterUPP filterProc =NewNavObjectFilterProc( myFilterProc );	long count, index;		theErr = NavGetDefaultDialogOptions( &dialogOptions );	dialogOptions.dialogOptionFlags -= kNavDontAddTranslateItems;	//dialogOptions.dialogOptionFlags |= kNavSelectAllReadableItem;	dialogOptions.dialogOptionFlags |= kNavNoTypePopup;		BlockMoveData(_maccur_pgm_name, (dialogOptions.clientName)+1, strlen(_maccur_pgm_name));	(dialogOptions.clientName)[0] = strlen(_maccur_pgm_name);	BlockMoveData(message, dialogOptions.message, message[0]+1);	//BlockMoveData(defName, dialogOptions.savedFileName, defName[0]+1);	/*	openTypeList = NewHandle(12);	HLock(openTypeList);	typ = (UInt8*)(*openTypeList);	*((UInt32*)(typ))='jRge';	*((UInt32*)(typ+4))=1;	*((UInt32*)(typ+8))='----';	HUnlock(openTypeList);	*/	//openTypeList = (NavTypeListHandle)GetResource( 'open',128 );	openTypeList=NULL;	theErr = NavGetFile( NULL, &theReply, &dialogOptions,eventProc,					NULL, NULL, openTypeList, NULL );	if ( theReply.validRecord && theErr == noErr ){		static FSSpec finalFSSpec;		AEDesc resultDesc;		if ((theErr = AEGetNthDesc( &(theReply.selection), 1, typeFSS, &aKeyWord, &resultDesc ))== noErr){#if TARGET_CARBON			AEGetDescData(&resultDesc, resultSpec, sizeof(FSSpec));#else			BlockMoveData(*resultDesc.dataHandle,resultSpec,sizeof(FSSpec) );#endif				result = true;		}	}	//DisposeHandle((NavTypeListHandle)openTypeList);#if TARGET_CARBON	DisposeNavEventUPP(eventProc);#else	DisposeRoutineDescriptor(eventProc);#endif	return result;}Boolean putNavFile(StringPtr defName, StringPtr message, FSSpecPtr resultSpec){	OSErr theErr = noErr;	NavReplyRecord theReply;	NavDialogOptions dialogOptions;	NavTypeListHandle openTypeList = NULL;	Boolean  result = false;	AEKeyword aKeyWord;	static FSSpec systemFile;#if TARGET_CARBON	NavEventUPP eventProc = NewNavEventUPP(myNavEventProc );#else	NavEventUPP eventProc = NewNavEventProc(myNavEventProc );#endif	//NavObjectFilterUPP filterProc =NewNavObjectFilterProc( myFilterProc );	long count, index;		theErr = NavGetDefaultDialogOptions( &dialogOptions );	dialogOptions.dialogOptionFlags -= kNavDontAddTranslateItems;	dialogOptions.dialogOptionFlags |= kNavNoTypePopup;	BlockMoveData(_maccur_pgm_name, (dialogOptions.clientName)+1, strlen(_maccur_pgm_name));	(dialogOptions.clientName)[0] = strlen(_maccur_pgm_name);	BlockMoveData(message, dialogOptions.message, message[0]+1);	BlockMoveData(defName, dialogOptions.savedFileName, defName[0]+1);	//openTypeList = (NavTypeListHandle)GetResource( 'open',128 );	theErr = NavPutFile( NULL, &theReply, &dialogOptions,eventProc,					'rgSv', mySignature,NULL );	if ( theReply.validRecord && theErr == noErr ){		static FSSpec finalFSSpec;		AEDesc resultDesc;		if ((theErr = AEGetNthDesc( &(theReply.selection), 1, typeFSS, &aKeyWord, &resultDesc ))== noErr){#if TARGET_CARBON			AEGetDescData(&resultDesc, resultSpec, sizeof(FSSpec));#else			BlockMoveData(*resultDesc.dataHandle,resultSpec,sizeof(FSSpec) );#endif			if (theReply.replacing){				FSpDelete(resultSpec);			}				result = true;		}	}#if TARGET_CARBON	DisposeNavEventUPP(eventProc);#else	DisposeRoutineDescriptor(eventProc);#endif	return result;}char* macGetEnv(char* envname){	if (strcmp(envname, "ROGUEOPTS")==0) {				//static char macOpts[1024];		return getPrefsOpts();		//Handle h = GetPrefsText();		/*		macOpts[0] = '\0';		if ( h != NULL){			unsigned int l = GetHandleSize(h);			if (l > 1023) {				l = 1023;			}			BlockMoveData(*h, macOpts, l);			macOpts[l] = '\0';		}		return macOpts;		*/	} else {		char *getenv();		return getenv(envname);	}	return NULL;}void SetCheckValue(DialogRef dp, int item, Boolean val){	short iType;	Rect iRect;	Handle iHandle = NULL;	ControlRef ctl = NULL;	ControlID   Cid;	Cid.signature='cbox';	Cid.id=item;	GetControlByID(dp, &Cid, &ctl);	if (ctl){		SInt16 v;		if (val) v=1; else v=0;					SetControlValue(ctl,v); 	}}Boolean GetCheckValue(DialogRef dp, int item){	short iType;	Rect iRect;	Handle iHandle = NULL;	Boolean result = false;	ControlRef ctl = NULL;	ControlID   Cid;	Cid.signature='cbox';	Cid.id=item;	GetControlByID(dp, &Cid, &ctl);	if (ctl){		return GetControlValue(ctl);	}}void SetDText(DialogRef dp, int item , char* data){	short iType;	Rect iRect;	Handle iHandle = NULL;	ControlRef ctl = NULL;	ControlID   Cid;	Cid.signature='edit';	Cid.id=item;	GetControlByID(dp, &Cid, &ctl);	if (ctl){		SetControlData(ctl, kControlNoPart, kControlEditTextTextTag, strlen(data),data);	}}void cutSpace(DialogRef dp, int item ,char* data){	char buf[BUFSIZ];	if (data && *data){		int l,limit;		strcpy(buf,data);		l = strlen(buf);		if (buf[l-1] == ' ')			buf[l-1] = '\0';		if (buf[0] == ' ')			BlockMoveData(buf+1,buf,l+1);		SetDText(dp,item,buf);	}	}void GetDtext(DialogRef dp, int item , char* result){	short iType;	Rect iRect;	Handle iHandle = NULL;	ControlRef ctl = NULL;	ControlID   Cid;	Cid.signature='edit';	Cid.id=item;	GetControlByID(dp, &Cid, &ctl);	if (ctl){		Size l;		GetControlData(ctl, kControlNoPart, kControlEditTextTextTag, BUFSIZ ,result,&l);		result[l]='\0';	}//	GetDialogItem(dp,item, &iType,  &iHandle,&iRect);}void readCurrentPrefs(DialogRef dp){	FSSpec target;	Boolean wasChanged;	AliasHandle theAlias;	char msgname[BUFSIZ];	OSErr err;	extern opt envopt[];	int i;	for (i = 0; ;i++){		if  (envopt[i].name ==NULL ){			break;		} else if (strcmp(envopt[i].name,"askquit") ==0 ){		} else if (strcmp(envopt[i].name, "jump") == 0) {			SetCheckValue(dp,kshowMoveCheck,*(envopt[i].bp));		} else if (strcmp(envopt[i].name,"passgo") ==0 ){			SetCheckValue(dp,kPassGoCheck,*(envopt[i].bp));		} else if (strcmp(envopt[i].name,"tombstone") ==0 ){			SetCheckValue(dp,kTombCheck,*(envopt[i].bp));		} else if (strcmp(envopt[i].name,"color") ==0 ){			SetCheckValue(dp,kColorCheck,*(envopt[i].bp));		} else if (strcmp(envopt[i].name,"fruit") ==0 ){			cutSpace(dp,kFruite,*(envopt[i].cp));		} else if (strcmp(envopt[i].name,"file") ==0 ){		} else if (strcmp(envopt[i].name,"name") ==0 ){			cutSpace(dp,kName,*(envopt[i].cp));		} else if (strcmp(envopt[i].name,"directory") ==0 ){		} else if (strcmp(envopt[i].name,"map") ==0 ){		} else if (strcmp(envopt[i].name,"font") ==0 ){		} else if (strcmp(envopt[i].name,"size") ==0 ){		}			}	strcpy(msgname,msgName);	if (tmpAlias){		DisposeHandle((Handle)tmpAlias);	}	tmpAlias = NULL;	theAlias =(AliasHandle) getMessageAlias();//GetNamedResource('Alis',msgResName);	if (theAlias){		err = ResolveAlias(NULL,theAlias,&target,&wasChanged);		if (err == noErr){			tmpAlias = theAlias;			if (wasChanged){				saveMessageAlias(theAlias);				//ChangedResource((Handle)theAlias);			}			BlockMoveData((target.name)+1,msgname,(target.name)[0]);			msgname[(target.name)[0]] = '\0';		}	}	tmpAlias = NULL;	cutSpace(dp,kMsg,msgname);	}char *setCurrentPrefs(DialogRef dp){	static char optbuf[BUFSIZ];	char tmpbuf[BUFSIZ];	int i;	optbuf[0] = 0;	if (GetCheckValue(dp, kPassGoCheck)){		strcat(optbuf,"passgo,");	} else {		strcat(optbuf,"nopassgo,");	}	if (GetCheckValue(dp, kshowMoveCheck)){		strcat(optbuf,"jump,");	} else {		strcat(optbuf,"nojump,");	}	if (GetCheckValue(dp, kTombCheck)){		strcat(optbuf,"tombstone,");	} else {		strcat(optbuf,"notombstone,");	}	if (GetCheckValue(dp, kColorCheck)){		strcat(optbuf,"color,");	} else {		strcat(optbuf,"nocolor,");	}	GetDtext(dp, kFruite,tmpbuf);	if (strlen(tmpbuf)==0)		strcat(tmpbuf,mesg[333]);	strcat(optbuf,"fruit:");	strcat(optbuf,tmpbuf);	strcat(optbuf,",");	GetDtext(dp, kName,tmpbuf);	strcat(optbuf,"name:");	strcat(optbuf,tmpbuf);	strcat(optbuf,",font:");	strcat(optbuf,_maccur_font_name);	strcat(optbuf,",size:");	sprintf(tmpbuf,"%d",_maccur_font_size);	strcat(optbuf,tmpbuf);	return optbuf;}static pascal Boolean myModalFilter(DialogPtr theDialog, EventRecord *theEvent, DialogItemIndex *itemHit){	short theChar;	switch(theEvent->what){		//case kHighLevelEvent:		case updateEvt:			if ((WindowPtr)theEvent->message == (WindowPtr)theDialog)				return false;			else				//maccur_process1Event(0,theEvent);			return true;			break;		default:			return false;	}	return false;}pascal OSStatus prefsDialogEventHandler(EventHandlerCallRef myHandler, EventRef event, void *userData){	short ret=eventNotHandledErr;	WindowRef   wptr;	GrafPtr	cptr;	HICommand   cmd;	char tmpc[256];	boolean selected=false;	GetPort(&cptr);	wptr= (WindowRef)userData;	if (GetEventClass(event) == kEventClassCommand){		switch(GetEventKind(event)){			case kEventProcessCommand:				GetEventParameter( event, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL,&cmd);				switch(cmd.commandID){					case 'ok  ':					case 'not!':						SetWRefCon(wptr, cmd.commandID);						QuitAppModalLoopForWindow(wptr);						ret = noErr;						break;					case 'open':						selected =false;						selected = getNavFile(msg_file_msg,&msgSpec);						if (selected){							if (tmpAlias){								DisposeHandle((Handle)tmpAlias);							}							NewAlias(NULL,&msgSpec,&tmpAlias);							BlockMove((msgSpec.name)+1, tmpc, (msgSpec.name)[0]);							tmpc[(msgSpec.name)[0]] = '\0';							SetDText(wptr,kMsg,tmpc);							//DrawDialog(wptr);						}						break;					case 'Dflt':						if (tmpAlias){							DisposeHandle((Handle)tmpAlias);							tmpAlias = NULL;						}						SetDText(wptr, kMsg ,msgName);						break;					default:				}				break;		}	}	SetPort(cptr);	return ret;}AliasHandle getMessageAlias(void){	Handle result = NULL;	CFDataRef data;	int len;	data = CFPreferencesCopyAppValue(CFSTR("MessageAlias"),kCFPreferencesCurrentApplication);	if (data){		len = CFDataGetLength(data);		if (len ){			result=NewHandle(len);			HLock(result);			CFDataGetBytes(data,CFRangeMake(0,len), *result);			HUnlock(result);		} else {			result = NULL;		}	}	return result;}void saveMessageAlias(AliasHandle h){	CFDataRef data=NULL;	if (h){		HLock(h);		data = CFDataCreate(NULL,*h, GetHandleSize(h));		HUnlock(h);	}	CFPreferencesSetAppValue(CFSTR("MessageAlias"), data, kCFPreferencesCurrentApplication);	CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);}void myEditOptions(void)	// edit options with dialog{	//ModalFilterUPP myModalFilterUPP = NewModalFilterUPP((ModalFilterProcPtr)myModalFilter);	short itemHit;	short iType;	Rect iRect;	Handle iHandle;	FSSpec msgSpec;	UInt8 mName[BUFSIZ];	Boolean selected = false;	IBNibRef 		nibRef;	OSStatus		err;	DialogRef		dialog;	EventTypeSpec list[]={ kEventClassCommand, kEventProcessCommand };	err = CreateNibReference(CFSTR("main"), &nibRef);	err = CreateWindowFromNib(nibRef, CFSTR("Prefs"), &dialog);	DisposeNibReference(nibRef);	//DialogPtr dp = GetNewDialog(200,NULL,(WindowPtr)-1);	DialogRef dp=dialog;	if (dp != NULL){		//SetDialogDefaultItem(dp,kOKButton);		//SetDialogCancelItem(dp,kCancelButton);		readCurrentPrefs(dp);		InstallWindowEventHandler(dp,NewEventHandlerUPP(prefsDialogEventHandler), 1, list,dp,NULL);		ShowWindow(dp);		RunAppModalLoopForWindow(dp);		if (GetWRefCon(dp) =='ok  '){			int ac = 2;			char *av[2];			GetDtext(dp,kMsg, &mName);			if (strcmp(mName,msgName)==0){				if (tmpAlias){					DisposeHandle((Handle)tmpAlias);					tmpAlias = NULL;				}				macResetMessage();				av[0] = "rogue";				av[1] = getCurrentMsgFile();				read_mesg(ac,av);				print_stats(0);				print_stats(STAT_ALL);			}else if (tmpAlias){				Handle resAlias;				Size l;				l = GetHandleSize((Handle)tmpAlias);				resAlias = getMessageAlias(); //GetNamedResource('Alis',msgResName);				if (resAlias == NULL){					resAlias = NewHandle(l);					//UseResFile(prefsRefNum);					//AddResource(resAlias,'Alis',128,msgResName);									}				SetHandleSize(resAlias,l);				BlockMoveData(*tmpAlias,*resAlias,l);				saveMessageAlias(resAlias);				//ChangedResource(resAlias);				DisposeHandle((Handle)tmpAlias);				tmpAlias = NULL;				{					FSSpec spec;					//char tmpPath[256];					Boolean wasChanged;					OSErr err;					err = ResolveAlias(NULL,(AliasHandle)resAlias,&spec,&wasChanged);					if (err == noErr){						FSRef ref;						UInt8 newpath[4096];						if (FSpMakeFSRef (&spec,&ref)==noErr){							if (FSRefMakePath(&ref,newpath,4096 )==noErr){																				//makePath(&spec);								//strcpy(newpath, (char*)svFname);								av[0] = "rogue";								av[1] = newpath;								read_mesg(ac,av);							}						}						print_stats(0);						print_stats(STAT_ALL);					}				}			}			set_opts(setCurrentPrefs(dp));			refresh();		}else {				}		DisposeWindow(dp);		//DrawDialog(dp);		/*		do {					ModalDialog(NULL,&itemHit);			ModalDialog(myModalFilterUPP,&itemHit);			switch(itemHit){				case kColorCheck:				case kshowMoveCheck:				case kPassGoCheck:				case kTombCheck:				case kFontMenuCheck:					GetDialogItem(dp,itemHit,&iType,&iHandle,&iRect);					if (GetControlValue((ControlHandle)iHandle)==0){						SetControlValue((ControlHandle)iHandle, 1);					} else {						SetControlValue((ControlHandle)iHandle, 0);					}					break;				case kChooseMsg:					selected =false;					if (gUseNavigation){						selected = getNavFile(msg_file_msg,&msgSpec);					} else {					#if !TARGET_API_MAC_CARBON						selected = getOldFile(msg_file_msg,&msgSpec);					#endif					}					if (selected){						if (tmpAlias){							DisposeHandle((Handle)tmpAlias);						}						NewAlias(NULL,&msgSpec,&tmpAlias);						BlockMove((msgSpec.name)+1, tmpc, (msgSpec.name)[0]);						tmpc[(msgSpec.name)[0]] = '\0';						SetDText(dp,kMsg,tmpc);						DrawDialog(dp);					}					break;				case kResetMsg:					if (tmpAlias){						DisposeHandle((Handle)tmpAlias);						tmpAlias = NULL;					}					SetDText(dp, kMsg ,msgName);					break;			}		} while ((itemHit != kOKButton) && (itemHit !=kCancelButton));		if (itemHit == kOKButton){			int ac = 2;			char *av[2];			GetDtext(dp,kMsg,tmpc);			if (strcmp(tmpc,msgName)==0){				if (tmpAlias){					DisposeHandle((Handle)tmpAlias);					tmpAlias = NULL;				}				macResetMessage();				av[0] = "rogue";				av[1] = msgName;				read_mesg(ac,av);				print_stats(0);				print_stats(STAT_ALL);			} else if (tmpAlias){				Handle resAlias;				Size l;				l = GetHandleSize((Handle)tmpAlias);				resAlias = GetNamedResource('Alis',msgResName);				if (resAlias == NULL){					resAlias = NewHandle(l);					UseResFile(prefsRefNum);					AddResource(resAlias,'Alis',128,msgResName);				}				SetHandleSize(resAlias,l);				BlockMoveData(*tmpAlias,*resAlias,l);				ChangedResource(resAlias);				DisposeHandle((Handle)tmpAlias);				tmpAlias = NULL;				{					FSSpec spec;					char tmpPath[256];					Boolean wasChanged;					OSErr err;					err = ResolveAlias(NULL,(AliasHandle)resAlias,&spec,&wasChanged);					if (err == noErr){						makePath(&spec);						strcpy(tmpPath, (char*)svFname);						av[0] = "rogue";						av[1] = tmpPath;						read_mesg(ac,av);						print_stats(0);						print_stats(STAT_ALL);					}				}			}			set_opts(setCurrentPrefs(dp));			refresh();		}		DisposeDialog(dp);		DisposeModalFilterUPP(myModalFilterUPP);		*/	}	}/* myFree()****	ポインタが変数領域(スタック)を指していなければ、ヒープ中に確保**	されたものとみなして解放する****/void myFree(char *s){	//THz myZone;	//myZone = GetZone();	//if (s > (char*)myZone && s < (char*)(myZone->bkLim))	/* it is in heap space */	//	free(s);}void checkMenus(void){	short num,i,len,fnum;	long fsize;	Str255 piname;	char iname[256];	fnum = 0;#if TARGET_API_MAC_CARBON	fontMenu = GetMenuHandle(131);	num = CountMenuItems(fontMenu);#else	fontMenu = GetMenu(131);	num = CountMItems(fontMenu);#endif	for (i = 1 ; i <= num; i++){		GetMenuItemText(fontMenu,i,piname);		len = piname[0];		BlockMoveData(piname+1,iname,piname[0]);		iname[piname[0]] = '\0';		if (strcmp(iname,_maccur_font_name) !=0 ){#if TARGET_API_MAC_CARBON			CheckMenuItem(fontMenu,i,FALSE);#else			CheckItem(fontMenu,i,FALSE);#endif		}else{#if TARGET_API_MAC_CARBON			CheckMenuItem(fontMenu, i, TRUE);#else			CheckItem(fontMenu, i, TRUE);#endif			GetFNum(piname,&fnum);					}	}#if TARGET_API_MAC_CARBON	sizeMenu = GetMenuHandle(132);	num = CountMenuItems(sizeMenu);#else	sizeMenu = GetMenu(132);	num = CountMItems(sizeMenu);#endif	for ( i=1; i<=num; i++){		GetMenuItemText(sizeMenu,i,piname);#if TARGET_API_MAC_CARBON		CheckMenuItem(sizeMenu,i, FALSE);#else		CheckItem(sizeMenu,i, FALSE);#endif		StringToNum(piname,&fsize);		if (RealFont(fnum,fsize))			SetItemStyle(sizeMenu,i,outline);		if (_maccur_font_size == fsize)#if TARGET_API_MAC_CARBON			CheckMenuItem(sizeMenu,i, TRUE);#else			CheckItem(sizeMenu,i, TRUE);#endif	}}char* getPrefsFontName(void){	CFStringRef fontName;	static char fname[BUFSIZ]={0};	char* result = NULL;	fontName = CFPreferencesCopyAppValue(CFSTR("Font"), kCFPreferencesCurrentApplication);	if (fontName){#ifdef JAPAN		CFStringGetCString(fontName, &fname, BUFSIZ-1, kCFStringEncodingMacJapanese);#else		CFStringGetCString(fontName, &fname, BUFSIZ-1, kCFStringEncodingMacRoman);#endif		if (fname[0]){			result=fname;		}		CFRelease(fontName);	}	return result;}int getPrefsFontSize(void){	CFNumberRef fontSize;	int fsize=0;	fontSize = CFPreferencesCopyAppValue(CFSTR("Size"), kCFPreferencesCurrentApplication);	if (fontSize){		CFNumberGetValue(fontSize, kCFNumberIntType, &fsize);		CFRelease(fontSize);	}		return fsize;}/**************************Save screen as PICT file***************************/void	SaveAsPict(void){	#define defName "\progue.pict"#ifdef JAPAN	#define message "\pPICTとして保存します..."#else	#define message "\pSave as PICT..."#endif	FSSpec spec= {0};	char head[512] = {0};	Boolean okSave = false;	PicHandle pc = GetWindowPict();	if (pc != NULL){		okSave = putNavFile(defName, message, &spec);		if (okSave){			OSErr iErr;			short refNum;			iErr = FSpCreate(&spec,'ttxt','PICT',smSystemScript);			if (iErr == noErr || iErr == dupFNErr){				iErr = FSpOpenDF(&spec,fsRdWrShPerm,&refNum);				if (iErr == noErr){					long inOutCount = 512;					HLock((Handle)pc);					FSWrite(refNum,&inOutCount, head);					inOutCount = GetHandleSize((Handle)pc);					FSWrite(refNum, &inOutCount, *pc);					FSClose(refNum);					HUnlock((Handle)pc);				}			}		}		KillPicture(pc);	}	}void showAbout(void){	}void putPictScrap(void){	PicHandle pc = NULL;	pc = GetWindowPict();	if (pc != NULL){		Size len = GetHandleSize((Handle)pc);		HLock((Handle)pc);#if TARGET_API_MAC_CARBON		{			OSStatus result;			ScrapRef curScrap;			result = ClearCurrentScrap();			result = GetCurrentScrap(&curScrap);			result = PutScrapFlavor( curScrap,kScrapFlavorTypePicture,kScrapFlavorMaskNone,len,*pc);		}#else		ZeroScrap();		PutScrap(len, 'PICT', *pc);#endif		HUnlock((Handle)pc);		KillPicture(pc);	}}void showGuide(void){	CFURLRef defURL;	defURL = CFBundleCopyResourceURL( CFBundleGetMainBundle(), CFSTR("rogueguide"), CFSTR("html"), NULL);	LSOpenCFURLRef(defURL, NULL);	}pascal OSStatus doCommand(EventHandlerCallRef myhandler, EventRef event, void* userData){	long id,class;	unsigned long kind;	extern OSStatus setCurFontToFontPanel(void);	HICommand cmd;	OSStatus	result = eventNotHandledErr;	class=GetEventClass(event);	kind=GetEventKind(event);	if (class==kEventClassCommand){		if (kind==kEventProcessCommand){			GetEventParameter(event, kEventParamDirectObject, typeHICommand, NULL,sizeof(HICommand),NULL,&cmd);							switch(cmd.commandID){				case 'abou':					showAbout();					//result=noErr;					break;				case 'pref':					myEditOptions();					result=noErr;					break;				case 'quit':					doQuit();					result=noErr;					break;				case 'open':										break;				case 'copy':					putPictScrap();					result=noErr;					break;				case 'svtx': // save as TEXT					save_screen();					result=noErr;					break;				case 'svpc': // save as PICT					SaveAsPict();					result=noErr;					break;				case 'save': // save and Quit					save_game();					result=noErr;					break;				case 'shfp':					result = setCurFontToFontPanel();					result=FPShowHideFontPanel();										break;				case 'help':					doPutKey('?');					break;				case 'gide':					showGuide();					break;				case 'shit':					result=ToggleDrawer(itemWin);					break;				case 'use!':					useItem();					break;				case 'drop':					dropItem();					break;							}		}	} else if (class == kEventClassApplication){		if (kind== kEventAppQuit){			quit(0);		}	} else if (class == kEventClassKeyboard){		if (kind == kEventRawKeyDown || kind == kEventRawKeyRepeat){			unsigned char c;			UInt32 k,m;			GetEventParameter(  event, kEventParamKeyCode, typeUInt32, NULL, sizeof(UInt32), NULL,&k);			GetEventParameter(  event, kEventParamKeyMacCharCodes, typeChar, NULL, sizeof(unsigned char), NULL,&c);			GetEventParameter(  event, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL,&m);			doType(c,k,m);			result=noErr;		}	}	return result;}/*void	doMenu(short menuID,short itemNo){	Str255	Item;	char *tptr;	static char cItem[256];	short	len;	long	dummy;	MenuHandle mH;#if TARGET_API_MAC_CARBON	mH = GetMenuHandle(menuID);	return;#else	mH = GetMenu(menuID);#endif	switch (menuID){		case 128:			if (itemNo == 1){				DialogPtr ad;				short itemHit;				ad = GetNewDialog(201,NULL,(WindowPtr)-1);				ShowWindow(GetDialogWindow(ad));				DrawDialog(ad);				ModalDialog(NULL,&itemHit);				DisposeDialog(ad);							} else {				Str255 tmpstr;				GrafPtr savePort;				GetMenuItemText(mH, itemNo,tmpstr);#if !TARGET_API_MAC_CARBON				GetPort(&savePort);				OpenDeskAcc(tmpstr);				SetPort(savePort);#else				if (EqualString(tmpstr, PREF_ITEM, TRUE,TRUE)){					myEditOptions();				}#endif			}			break;		case 129:			switch (itemNo){				case dumpItem://Dump screen										mCmd = '\004';					save_screen();					break;				case dumpPictItem:										mCmd = 0;					SaveAsPict();					break;				case saveItem://save					mCmd = 'S';					save_game();					break;				case optionItem:					myEditOptions();					break;				case quitItem://quit					mCmd = 'Q';					quit(0);					break;				default:					mCmd = 0;								}			if (mCmd){						}			break;		case 130:			if (itemNo == copyItem){	// Copy				PicHandle pc = NULL;				pc = GetWindowPict();				if (pc != NULL){					Size len = GetHandleSize((Handle)pc);					HLock((Handle)pc);			#if TARGET_API_MAC_CARBON					{						OSStatus result;						ScrapRef curScrap;						result = ClearCurrentScrap();						result = GetCurrentScrap(&curScrap);						result = PutScrapFlavor( curScrap,kScrapFlavorTypePicture,kScrapFlavorMaskNone,len,*pc);					}			#else					ZeroScrap();					PutScrap(len, 'PICT', *pc);			#endif					HUnlock((Handle)pc);					KillPicture(pc);				}			}			break;		case 131:	//font			GetMenuItemText(mH,itemNo,Item);			len = Item[0];			//myFree(font_name);			BlockMoveData(Item+1,fntName,len);			fntName[len] = '\0';			font_name = fntName;			_maccur_font_name=font_name;			reInit_window();			break;		case 132:	//size			GetMenuItemText(mH,itemNo,Item);			len = Item[0];			//myFree(font_size);			BlockMoveData(Item+1, fntSize,len);			fntSize[len] = '\0';			font_size = fntSize;			StringToNum(Item,&dummy);			_maccur_font_size=(short)dummy;			if (_maccur_font_size>24)				_maccur_font_size=24;			reInit_window();			break;	}}*//* CODE EXAMPLE #1 */// Getting a Full Pathname// Utilities from the Apple Q&A Stack showing how to get the full// pathname of a file.  Note that this is NOT the recommended way// to specify a file to Toolbox routines.  These routines should be// used for displaying full pathnames only.void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName);void pstrcat(StringPtr dst, StringPtr src);void pstrinsert(StringPtr dst, StringPtr src);// Assumes inclusion of <MacHeaders>#define haveAUX() 0/* * Pascal string utilities *//* * pstrcat - add string 'src' to end of string 'dst' */void pstrcat(StringPtr dst, StringPtr src){	/* copy string in */	BlockMove(src + 1, dst + *dst + 1, *src);	/* adjust length byte */	*dst += *src;}/* * pstrinsert - insert string 'src' at beginning of string 'dst' */void pstrinsert(StringPtr dst, StringPtr src){	/* make room for new string */	BlockMove(dst + 1, dst + *src + 1, *dst);	/* copy new string in */	BlockMove(src + 1, dst + 1, *src);	/* adjust length byte */	*dst += *src;}void PathNameFromDirID(long dirID, short vRefNum, StringPtr fullPathName){	DirInfo	block;	Str255	directoryName;	OSErr	err;	fullPathName[0] = '\0';	block.ioDrParID = dirID;	block.ioNamePtr = directoryName;	do {			block.ioVRefNum = vRefNum;			block.ioFDirIndex = -1;			block.ioDrDirID = block.ioDrParID;			err = PBGetCatInfoSync((CInfoPBRec*)&block);			if (haveAUX()) {					if (directoryName[1] != '/')							/* If this isn't root (i.e. "/"), append a slash ('/') */							pstrcat(directoryName, (StringPtr)"\p/");			}			else					pstrcat(directoryName, (StringPtr)"\p:");			pstrinsert(fullPathName, directoryName);	} while (block.ioDrDirID != 2);}void makePath(FSSpecPtr myFSS){	OSStatus err;	FSRef ref;	char test[BUFSIZ];	err=FSpMakeFSRef(myFSS, &ref);	err=FSRefMakePath(&ref, svFname, sizeof(svFname));/*	short len;	PathNameFromDirID(myFSS->parID, myFSS->vRefNum, svFname);	pstrcat(svFname,myFSS->name);	len = svFname[0];	memmove(svFname,svFname+1,len);	svFname[len]='\0';*/}void macChooseFileName(char* fname){	FSSpec spec;	Str255 defname;	char defc[256];	int len;	extern char* save_file;	if (save_file && *save_file){		len = strlen(save_file);		BlockMoveData(save_file,defname+1,len);		defname[len] = '\0';	} else {		StringPtr defdef = "\progue.save";		BlockMoveData(defdef,defname, defdef[0]+1);	}#ifdef JAPAN	#define comment "\pセーブするファイル名は？"#else	#define comment "\pFile name?"#endif	if ( putNavFile(defname,comment,&spec)){		char tmp[1024];		int len = (spec.name)[0];		BlockMoveData((spec.name)+1,tmp,len);		tmp[len]='\0';		FSpCreate(&spec,'jRge','rgSv',smSystemScript);		makePath(&spec);		strcpy(fname,(char*)svFname);		return;	}	fname[0] = 0;	return;}char* getCurrentMsgFile(void){	AliasHandle theAlias;	Handle dummyOpts;	FSSpec getFSSpec, prefsSpec;	Boolean wasChanged;	short foundVrefNum;	long foundDirID;	OSErr err;	strcpy(msgPath,msgName);	//dummyOpts = GetPrefsText(); // meaningless, but need to open prefs file		theAlias  = getMessageAlias(); //(AliasHandle)GetNamedResource('Alis',msgResName);	if(theAlias == NULL){		return msgPath;	}	err = ResolveAlias(NULL,theAlias,&getFSSpec,&wasChanged);	if (wasChanged) {		saveMessageAlias(theAlias);		//ChangedResource((Handle)theAlias);	}	if (err == noErr){		makePath(&getFSSpec);		strcpy(msgPath,(char*)svFname);		return msgPath;	}}/*------		reset message file----*/void macResetMessage(void){	AliasHandle theAlias;	theAlias  = getMessageAlias();// (AliasHandle)GetNamedResource('Alis',msgResName);	if (theAlias){		//RemoveResource((Handle)theAlias);		DisposeHandle((Handle)theAlias);		theAlias = NULL;		saveMessageAlias(NULL);	}}static Size curMsgPos;static Handle curMsgHandle;FILE *df;int openResMsg(void){	CFURLRef defURL;	UInt8 pathRef[4096];	FILE *tmpF;	defURL = CFBundleCopyResourceURL( CFBundleGetMainBundle(), CFSTR("default"), CFSTR("txt"), NULL);	if (defURL){		CFURLGetFileSystemRepresentation(defURL,FALSE,pathRef,4096);		tmpF = fopen(pathRef,"r");		df=tmpF;		return 0;	}	/*	curMsgHandle = GetNamedResource('TEXT',"\pDefault Message");	curMsgPos = 0;	if (curMsgHandle){		HLockHi(curMsgHandle);		//df=fopen("debugog.txt", "w");		return 0;	}	else		return 1;	*/	return 1;}char *fgetsRes(char* buf, int num){	return fgets(buf,num,df);	/*	int i = 0;	char c;	char *curbuf=buf;	Size hSize = GetHandleSize(curMsgHandle);	if (curMsgPos >= hSize){		return NULL;	}	for (i = 0;i<num-1 ; i++){		if ( curMsgPos+i >= hSize || (( c = (*curMsgHandle)[curMsgPos+i])=='\r') ){			*curbuf = '\0';			//fprintf(df, "%s\n",buf);			curMsgPos += i+1;			return buf;		}		*curbuf++ = c;	}	*curbuf = '\0';	curMsgPos += curMsgPos+i;	return buf;	*/}void closeResMsg(void){/*	HUnlock(curMsgHandle);	ReleaseResource(curMsgHandle);	*/	fclose(df);}int read_default_mesg(void){	char buf[256];	int i, n, s, e;	if (openResMsg()) {		maccur_alert_msg("Cannot open default message\n");		return 1;	}	while (fgetsRes(buf, 256) != NULL) {		if ((n = atoi(buf)) > 0 && n < 500) {			for (i = 0; buf[i] && buf[i] != '\"'; ++i)				;			if (buf[i])				s = i + 1;			else {FMTERR:								closeResMsg();				return 1;			}			for (i = s; buf[i] && buf[i] != '\"'; ++i)				;			if (buf[i])				e = i - 1;			else				goto FMTERR;			for (i = 0; i < e-s+1 && i < 79; ++i)				mesg[n][i] = buf[s + i];			mesg[n][i] = '\0';		}	}	closeResMsg();	return 0;}// set filetype and creatorvoid fsetfileinfo (char *file, long crea, long type){	FSRef ref;	FSSpec spec;	FInfo fileinfo;		FSPathMakeRef(file,&ref,NULL);	FSGetCatalogInfo(&ref,kFSCatInfoFinderInfo,NULL,NULL,&spec,NULL);	FSpGetFInfo(&spec,&fileinfo);	fileinfo.fdType=type;	fileinfo.fdCreator=crea;	FSpSetFInfo(&spec,&fileinfo);}pascal void mymain(void *refCon){	extern int myArgc;	extern char *myArgv;	OSErr err;	EventRecord firstEvent;	char *largv[10];	int largc,i;	short oRef,h,l;	char *pt;	char saveFile[256];	char * fname;	int fsize;	extern boolean wizard;	extern boolean score_only;	gUseNavigation = false;	if (NavServicesAvailable ()){		gUseNavigation = true;		if (NavLoad ()!=noErr){			gUseNavigation = false;		}	}	curscr = initscr();	curscr->_use_keypad = true;	/*	while (!ok_go_on){		YieldToAnyThread();		//maccur_cpu_share();	}	*/	//init_rogueMenu();	if (svFname[0]){		strcpy(saveFile, (char*)svFname);		largc = 3;		largv[2] = saveFile;	} else {		largc = 2;	}	largv[0] = "rogue";	largv[1] = getCurrentMsgFile();		InitCursor();	//wizard = 1; //test wizard	//game_dir=getSytemPrefsFolder();	fname = getPrefsFontName();	if (fname){		_maccur_font_name = fname;	}	fsize = getPrefsFontSize();	if (fsize){		_maccur_font_size = fsize;	}	reInit_window();	loadWindowPosition();	//SetWindowAlpha (the_windo,0.6);	ShowWindow(the_windo);	//InstallItemListEvents();	curesInstallEvent();	installDrawerKeyEvent();	roguemain(largc,largv);	return 0;}unsigned char *listData[30]={"111"};int listCount=10;static OSStatus setGetItemData(ControlRef browser, DataBrowserItemID itemID, 						DataBrowserPropertyID propertyID,						DataBrowserItemDataRef itemData, Boolean changeValue){	short ret=errDataBrowserPropertyNotSupported;	CFStringRef cref=NULL;	char* dummy=listData[itemID-1];	if (dummy)	cref=CFStringCreateWithCString(NULL,dummy, kCFStringEncodingMacJapanese);	//cref=CFStringCreateWithCString(NULL,"これはテストです", kCFStringEncodingMacJapanese);	if (cref)	SetDataBrowserItemDataText(itemData,cref);	if(cref) CFRelease(cref);		return noErr;}static void itemDataNotofication( ControlRef browser, DataBrowserItemID itemID, 			UInt32 mess){	ControlRef c;	ControlID   Cid;	Cid.signature='bton';	Cid.id=0;	int selected;	DataBrowserItemID first,last;	GetDataBrowserSelectionAnchor(browser, &first,&last);	if (first< 1){			Cid.signature='bton';			Cid.id=0;			GetControlByID(itemWin, &Cid, &c);			if (c) {				DisableControl(c);			}			Cid.id=1;			GetControlByID(itemWin, &Cid, &c);			if (c) {				DisableControl(c);			}			selected=FALSE;	} else {		selected = TRUE;	}	switch (mess)	{		case kDataBrowserItemDoubleClicked:			useItem();			break;		case kDataBrowserItemDeselected:			break;		case kDataBrowserItemSelected:			Cid.signature='bton';			Cid.id=0;			GetControlByID(itemWin, &Cid, &c);			if (c) {				EnableControl(c);			}			Cid.id=1;			GetControlByID(itemWin, &Cid, &c);			if (c) {				EnableControl(c);			}						break;	}}ControlRef itemListRef;DataBrowserCallbacks ItemCalls;void InstallItemListEvents(void){   	ControlID   Cid;	OSStatus result;		ControlRef c;	DataBrowserItemID item[30];	int i;	//OpenDrawer(itemWin,kWindowEdgeDefault,0);	for (i=0; i<30; i++)		item[i]=i;	Cid.signature='ilst';	Cid.id=0;	result =  GetControlByID(itemWin, &Cid, &c);	itemListRef = c;	ItemCalls.version=kDataBrowserLatestCallbacks;	result = InitDataBrowserCallbacks( &ItemCalls);	ItemCalls.u.v1.itemDataCallback = NewDataBrowserItemDataUPP(setGetItemData);	ItemCalls.u.v1.itemNotificationCallback = NewDataBrowserItemNotificationUPP(itemDataNotofication);	result = SetDataBrowserCallbacks(itemListRef, &ItemCalls);	result = AddDataBrowserItems(itemListRef, kDataBrowserNoItem, listCount, item,kDataBrowserItemNoProperty);	SetDataBrowserPropertyFlags(itemListRef, 'data', 0);}void updateList(){	OSStatus result;	int num=listCount;	//UInt32 curNum;	//GetDataBrowserItemCount(itemListRef, kDataBrowserNoItem, TRUE, 0,&curNum);	result = RemoveDataBrowserItems(itemListRef, kDataBrowserNoItem, 0,NULL,kDataBrowserItemNoProperty);	result = AddDataBrowserItems(itemListRef, kDataBrowserNoItem, listCount, NULL,kDataBrowserItemNoProperty);	result = UpdateDataBrowserItems( itemListRef, kDataBrowserNoItem, 0,NULL,kDataBrowserItemNoProperty,kDataBrowserNoItem);	}object *findObj(int num){	int i=0;	//num--;	object *obj = &rogue.pack;	while(obj){		if (num == i){			return obj;		}		i++;		obj = obj->next_object;	}	return NULL;}object *checkCurs(unsigned short kind){	int i=0;	object *obj = &rogue.pack;	while(obj){		if ((obj->in_use_flags !=0) && (obj->is_cursed) && (obj->what_is == kind))		{			return obj;		}				i++;		obj = obj->next_object;	}	return NULL;}object *checkWare(void){	int i=0;	object *obj = &rogue.pack;	while(obj){		if ((obj->in_use_flags !=0) &&(obj->what_is == ARMOR))		{			return obj;		}				i++;		obj = obj->next_object;	}	return NULL;}void useItem(void){	DataBrowserItemID first,last;	GetDataBrowserSelectionAnchor(itemListRef, &first,&last);	if (first > 0){		object *obj = findObj(first);		if (obj){			short id = obj->ichar;			switch(obj->what_is)			{				case SCROL: //scroll					doPutKey('r');					doPutKey(id);					break;				case POTION: //potion					doPutKey('q');					doPutKey(id);					break;				case WEAPON: //weapon					doPutKey('w');					if (!checkCurs(WEAPON))						doPutKey(id);					break;				case ARMOR: //armor					if (obj->in_use_flags){						doPutKey('T');						//doPutKey(id);					} else {						if (checkWare()){							doPutKey('T');							if (!checkCurs(ARMOR)){								doPutKey('W');								doPutKey(id);							}						}else{							doPutKey('W');							doPutKey(id);						}					}					break;				case RING: //rong					if (obj->in_use_flags){						doPutKey('R');						//doPutKey(id);					} else {						doPutKey('P');						doPutKey(id);					}					break;				case WAND: //wand					doPutKey('z');					//doPutKey(id);					break;				case FOOD: //food					doPutKey('e');					doPutKey(id);					break;			}		}	}	SelectWindow(the_windo);}void dropItem(void){	DataBrowserItemID first,last;	GetDataBrowserSelectionAnchor(itemListRef, &first,&last);	if (first > 0){		object *obj = findObj(first);		if (obj){			short id = obj->ichar;			doPutKey('d');			doPutKey(id);		}	}}